{
  "1": {
    "title": "Поняття комп'ютерної системи.",
    "content": "Комп'ютерна система — це сукупність апаратних засобів (hardware), програмного забезпечення (software) та даних, що взаємодіють для виконання обчислювальних завдань, обробки, зберігання та передачі інформації.\nКлючові компоненти:\nАпаратне забезпечення (Hardware): Фізичні компоненти системи.\nЦентральний процесор (CPU): \"Мозок\" комп'ютера, що виконує інструкції.\nОперативна пам'ять (RAM): Енергозалежне сховище для тимчасового зберігання даних та програм, з якими працює CPU.\nПостійна пам'ять (Storage): Енергонезалежні пристрої (HDD, SSD) для довготривалого зберігання ОС, програм та даних.\nПристрої введення/виведення (I/O Devices): Клавіатура, миша, монітор, мережева карта, принтери тощо.\nСистемна шина (System Bus): Канали для передачі даних та команд між компонентами.\nПрограмне забезпечення (Software): Набір інструкцій, що керують роботою апаратних засобів.\nСистемне ПЗ: Операційна система (ОС), драйвери, утиліти. ОС є основним інтерфейсом між апаратним забезпеченням та прикладними програмами, керує ресурсами системи.\nПрикладне ПЗ: Програми, що виконують конкретні завдання користувача (текстові редактори, веб-браузери, бази даних).\nВзаємодія: Апаратне забезпечення надає фізичну платформу для обчислень. Програмне забезпечення, зокрема ОС, керує цими апаратними ресурсами, надаючи абстрактний інтерфейс для прикладних програм та користувачів. Комп'ютерна система функціонує як єдине ціле для досягнення поставленої мети."
  },
  "2": {
    "title": "Використання КМОН-логіки в комп'ютерних системах.",
    "content": "КМОН (комплементарна структура метал-оксид-напівпровідник, англ. CMOS - Complementary Metal-Oxide-Semiconductor) — це технологія побудови електронних схем, яка є домінуючою в сучасній цифровій мікроелектроніці.\nПринцип роботи:\nКлючова особливість КМОН-логіки — використання пари комплементарних (доповнюючих) транзисторів: p-типу (PMOS) та n-типу (NMOS).\nЛогічний елемент (наприклад, інвертор): Вхідний сигнал подається одночасно на затвори обох транзисторів. При високому рівні напруги (логічна \"1\") n-MOS транзистор відкритий, а p-MOS — закритий, з'єднуючи вихід з землею (логічний \"0\"). При низькому рівні (логічний \"0\") — навпаки, p-MOS відкритий, а n-MOS закритий, з'єднуючи вихід з джерелом живлення (логічна \"1\").\nПереваги та застосування:\nНадзвичайно низьке статичне енергоспоживання: У стабільному стані (коли на вході \"0\" або \"1\") один із транзисторів завжди закритий, і струм через логічний елемент практично не протікає. Енергія споживається переважно в моменти перемикання стану (динамічне споживання). Це робить КМОН-технологію ідеальною для мобільних пристроїв та потужних процесорів, де тепловідведення є критичним.\nВисока завадостійкість: Логічні рівні \"0\" та \"1\" чітко розмежовані, що робить схеми стійкими до шумів.\nШирокий діапазон напруги живлення.\nЗастосування в комп'ютерних системах: На КМОН-логіці побудовані практично всі сучасні цифрові інтегральні схеми:\nМікропроцесори (CPU)\nМікроконтролери\nОперативна пам'ять (SRAM, DRAM)\nПостійна пам'ять (Flash)\nЧіпсети на материнських платах\nЛогічні мікросхеми (FPGA, CPLD)\nНевеликий блок КМОН-пам'яті з живленням від батарейки (CMOS RAM) на материнській платі використовується для зберігання налаштувань BIOS/UEFI.",
    "formulas": "КМОН-логіка — базується на використанні транзисторів MOSFET:\n  Логічний елемент AND:\n    Y = A · B\n\n  Логічний елемент OR:\n    Y = A + B\n\nде:\n  A, B — вхідні сигнали (0 або 1)\n  Y — вихідний сигнал\n\nПояснення:\n*   Простою мовою: Це базові \"цеглинки\" будь-якого комп'ютера. AND спрацює (дасть 1), тільки якщо обидва входи активні. OR спрацює, якщо хоча б один з входів активний.\n*   Професійно: Формули описують булеві функції для логічних вентилів AND та OR. Ці вентилі є основою комбінаційної логіки в цифрових схемах, реалізованих на КМОН-транзисторах."
  },
  "3": {
    "title": "Цифрова обробка даних в комп'ютерних системах.",
    "content": "Цифрова обробка даних — це маніпуляція даними, представленими у дискретній (цифровій) формі, за допомогою обчислювальних пристроїв. Всі дані в сучасних комп'ютерах (текст, зображення, звук, відео) кодуються у двійковому форматі.\nОсновні етапи:\nВведення (Input): Перетворення аналогових сигналів у цифрові (оцифровка) за допомогою АЦП (аналого-цифрового перетворювача) або введення вже існуючих цифрових даних.\nОбробка (Processing): Виконання арифметичних та логічних операцій над цифровими даними центральним процесором (CPU), графічним процесором (GPU) або спеціалізованими процесорами (DSP). Обробка відбувається згідно з алгоритмами, закладеними в програмному забезпеченні.\nЗберігання (Storage): Запис оброблених даних в оперативну або постійну пам'ять.\nВиведення (Output): Представлення результату користувачеві, наприклад, шляхом перетворення цифрових даних назад в аналоговий сигнал (за допомогою ЦАП) для виведення на монітор або динаміки, або передачі по мережі.\nПриклади цифрової обробки:\nТекст: Пошук, редагування, форматування.\nЗображення: Фільтрація, зміна яскравості/контрасту, розпізнавання об'єктів.\nАудіо: Видалення шумів, еквалізація, стиснення (MP3).\nНаукові дані: Статистичний аналіз, моделювання, візуалізація.\nЗначення: Цифрова обробка забезпечує точність, відтворюваність та можливість складних маніпуляцій, які неможливі або надзвичайно складні в аналоговому світі.",
    "formulas": "Цифрова обробка даних (напр. фільтрація):\n  y[n] = ∑_{k=0}^M h[k] · x[n-k]\n\nде:\n  x[n] — вхідний сигнал\n  h[k] — коефіцієнти фільтра\n  y[n] — вихідний сигнал\n  M — порядок фільтра\n\nПояснення:\n*   Простою мовою: Ця формула дозволяє \"очищувати\" сигнал (наприклад, аудіо від шумів). Кожне нове значення вихідного сигналу розраховується як середнє зважене з поточного та кількох попередніх значень вхідного сигналу.\n*   Професійно: Це рівняння описує операцію згортки для фільтра зі скінченною імпульсною характеристикою (FIR-фільтр). Вихідний сигнал y[n] є результатом застосування фільтра з коефіцієнтами h[k] до вхідного сигналу x[n]."
  },
  "4": {
    "title": "Теорія інформації. Кількість інформації. Ентропія.",
    "content": "Теорія інформації — це розділ прикладної математики, що вивчає кількісне вимірювання, зберігання та передачу інформації. Основоположником є Клод Шеннон.\nКількість інформації:\nІнформація отримується тоді, коли усувається невизначеність. Кількість інформації в повідомленні про подію залежить від ймовірності цієї події. Чим менш ймовірна подія, тим більше інформації несе повідомлення про неї.\nФормула Хартлі (для рівноймовірних подій):\nI = log₂(N)\nде I — кількість інформації в бітах, N — кількість можливих рівноймовірних подій.\nПриклад: Результат підкидання монети (N=2) несе log₂(2) = 1 біт інформації.\nФормула Шеннона (для подій з різною ймовірністю):\nI = -log₂(p)\nде p — ймовірність конкретної події.\nЕнтропія (H):\nЕнтропія — це математичне сподівання (середня кількість) інформації, що припадає на один елементарний символ первинного алфавіту. Вона вимірює середній рівень невизначеності системи.\nФормула ентропії Шеннона:\nH(X) = - Σ [p(xᵢ) * log₂(p(xᵢ))]\nде p(xᵢ) — ймовірність появи символу xᵢ з алфавіту X.\nМаксимальна ентропія: Досягається, коли всі події (символи) рівноймовірні. В цьому випадку H = log₂(N).\nМінімальна ентропія (нульова): Досягається, коли результат відомий наперед (ймовірність однієї події = 1, решти = 0). Невизначеність відсутня.\nЗначення: Ентропія визначає теоретичну межу стиснення даних без втрат. Неможливо стиснути дані так, щоб середня довжина кодового слова була меншою за ентропію джерела.",
    "formulas": "Ентропія (Інформація):\n  H(X) = - ∑ p(x) log₂ p(x)\n\nде:\n  H(X) — ентропія випадкової величини X\n  p(x) — ймовірність події x\n  ∑ — сума по всіх можливих подіях x\n\nПояснення:\n*   Простою мовою: Ентропія — це міра \"невизначеності\" або \"несподіванки\". Чим більше можливих і однаково ймовірних результатів, тим вища ентропія (наприклад, у кидка грального кубика ентропія вища, ніж у монетки).\n*   Професійно: Формула ентропії Шеннона, що кількісно визначає середній обсяг інформації в бітах (через log₂), який припадає на один елементарний результат випадкового експерименту. Використовується в теорії інформації та стисненні даних."
  },
  "5": {
    "title": "Кодування та стиснення інформації. Виявлення та корекція помилок.",
    "content": "Кодування інформації — це процес перетворення даних з однієї форми (наприклад, текстового символу) в іншу (наприклад, послідовність бітів) за певними правилами (кодом) для зберігання, передачі або обробки.\nСтиснення інформації (архівація) — це різновид кодування, метою якого є зменшення об'єму даних (усунення надлишковості).\nСтиснення без втрат (Lossless): Дозволяє точно відновити вихідні дані. Надлишковість усувається шляхом пошуку закономірностей та їх більш компактного представлення. Приклади: Lempel-Ziv (LZ77, LZW), кодування Хаффмана. Використовується для текстових файлів, програмних кодів, архівів (ZIP, GZIP).\nСтиснення із втратами (Lossy): Дозволяє значно зменшити об'єм даних, відкидаючи частину інформації, яка є несуттєвою для людського сприйняття. Оригінальні дані відновити неможливо. Приклади: JPEG (зображення), MP3 (аудіо), MPEG (відео).\nВиявлення та корекція помилок (Error Detection and Correction):\nПри передачі даних по зашумлених каналах (наприклад, мережа, радіозв'язок) або зчитуванні з носіїв (RAM, HDD) можуть виникати помилки (зміна біта 0->1 або 1->0). Для боротьби з цим використовуються коди, що заважають.\nВиявлення помилок (Error Detection): Додавання до даних надлишкової інформації, яка дозволяє перевірити їх цілісність.\nБіт парності (Parity Bit): Додається один біт, щоб загальна кількість одиниць у блоці була парною (even parity) або непарною (odd parity). Виявляє непарну кількість помилок.\nЦиклічний надлишковий код (CRC - Cyclic Redundancy Check): Потужний метод, що розглядає блок даних як поліном і обчислює \"залишок від ділення\" на фіксований поліном-генератор. Цей залишок (контрольна сума) додається до даних. Широко використовується в Ethernet, Wi-Fi, архіваторах.\nКорекція помилок (Error Correction, FEC - Forward Error Correction): Додавання ще більшої кількості надлишкової інформації, яка дозволяє не тільки виявити, але й виправити певну кількість помилок без повторної передачі.\nКоди Хеммінга: Класичний приклад коду, що може виправити одну помилку і виявити дві.\nКоди Ріда-Соломона: Блокові коди, що ефективно працюють з \"пакетними\" помилками (коли кілька біт підряд пошкоджено). Використовуються в CD/DVD, QR-кодах.\nECC-пам'ять (Error-Correcting Code memory): Спеціальний тип оперативної пам'яті, що використовується в серверах та критичних системах. Вона використовує додаткові біти для зберігання кодів корекції і може виправляти однобітові помилки \"на льоту\".",
    "formulas": "Код Хеммінга — виявлення та корекція помилок:\n  r = k + m\n  2^m ≥ r + 1\n\nде:\n  k — кількість бітів інформації\n  m — кількість перевіркових бітів\n  r — загальна довжина коду\n\nПояснення:\n*   Простою мовою: Це спосіб додати до даних (k) спеціальні перевірочні біти (m), щоб при передачі можна було автоматично знайти та виправити одну помилку.\n*   Професійно: Нерівність Хеммінга визначає мінімальну кількість надлишкових контрольних бітів (m), необхідних для створення коду, що виправляє одну помилку, для інформаційного повідомлення довжиною k біт."
  },
  "6": {
    "title": "Застосування скінченного автомату в комп'ютерних системах.",
    "content": "Скінченний автомат (Finite State Machine, FSM) — це математична модель обчислень, що описує систему, яка може перебувати в одному з скінченної кількості станів. Система може переходити з одного стану в інший у відповідь на зовнішні події (вхідні сигнали).\nКомпоненти скінченного автомату:\nСкінченна множина станів (S).\nСкінченна множина вхідних символів (Σ, алфавіт).\nФункція переходів (δ): Визначає наступний стан на основі поточного стану та вхідного символу (δ: S × Σ → S).\nПочатковий стан (s₀).\nМножина кінцевих (приймаючих) станів (F).\nТипи:\nДетермінований скінченний автомат (DFA): Для кожної пари (стан, вхідний символ) існує рівно один наступний стан.\nНедетермінований скінченний автомат (NFA): Для пари (стан, вхідний символ) може існувати кілька можливих наступних станів.\nЗастосування:\nЛексичний аналіз в компіляторах: Розпізнавання лексем (ключових слів, ідентифікаторів, операторів) у програмному коді. Кожен стан автомату відповідає частині лексеми, що розпізнається.\nМережеві протоколи: Опис станів з'єднання, наприклад, в TCP (LISTEN, SYN-SENT, ESTABLISHED, FIN-WAIT, CLOSED). Автомат змінює стан у відповідь на отримані пакети (SYN, ACK, FIN).\nАпаратне забезпечення: Проектування контролерів та послідовнісних логічних схем. Наприклад, контролер світлофора, автомат продажу квитків.\nТекстові редактори та утиліти: Реалізація пошуку за регулярними виразами (grep, sed). Регулярний вираз перетворюється на скінченний автомат для ефективного пошуку.\nВерифікація моделей (Model Checking): Перевірка правильності роботи апаратних та програмних систем шляхом аналізу графу станів.",
    "formulas": "Скінченний автомат:\n  δ: Q × Σ → Q\n\nде:\n  Q — множина станів\n  Σ — вхідна абетка\n  δ — функція переходів\n\nПояснення:\n*   Простою мовою: Це математична модель пристрою (наприклад, турнікету або автомата з напоями), який має скінченну кількість станів і переходить між ними залежно від вхідного сигналу.\n*   Професійно: Формула визначає функцію переходів (δ) детермінованого скінченного автомата (DFA). Вона відображає пару (поточний стан, вхідний символ) у наступний стан, що є основою для розпізнавання регулярних мов."
  },
  "7": {
    "title": "Доповняльний код для представлення від'ємних чисел.",
    "content": "Доповняльний код (Two's Complement) — це найпоширеніший метод представлення цілих чисел зі знаком у комп'ютерних системах. Він дозволяє виконувати операції додавання та віднімання за допомогою однієї і тієї ж апаратної схеми (суматора).\nПравила представлення в N-бітному форматі:\nДодатні числа: Представляються так само, як у прямому коді. Старший (знаковий) біт дорівнює 0. Діапазон: від 0 до 2^(N-1) - 1.\nВід'ємні числа: Щоб отримати доповняльний код від'ємного числа -X:\nВзяти двійкове представлення додатного числа X.\nІнвертувати всі біти (замінити 0 на 1 і 1 на 0). Цей результат називається оберненим кодом (one's complement).\nДодати до результату одиницю.\nСтарший (знаковий) біт у від'ємних чисел завжди дорівнює 1. Діапазон: від -2^(N-1) до -1.\nПриклад для 8 біт:\nЧисло 5: 00000101\nЧисло -5:\nБеремо 5: 00000101\nІнвертуємо: 11111010 (обернений код)\nДодаємо 1: 11111011 (доповняльний код)\nПереваги:\nЄдине представлення нуля: На відміну від прямого та оберненого кодів, де існує \"+0\" і \"-0\", в доповняльному коді нуль представлений унікально (00000000).\nСпрощення арифметики: Віднімання A - B виконується як додавання A + (-B), де -B представлено в доповняльному коді. Це дозволяє використовувати один і той же апаратний суматор для обох операцій, що значно спрощує дизайн АЛП (арифметико-логічного пристрою).\nПриклад: 7 - 5 = 7 + (-5)\n00000111 (7)\n+ 11111011 (-5)\n----------\n100000010 (2, перенесення за межі розрядної сітки ігнорується)",
    "formulas": "Доповняльний код (2-комплемент) для від’ємних чисел:\n  Представлення числа X (n-біт):\n    якщо X ≥ 0, то код = X\n    якщо X < 0, то код = 2^n + X\n\nде:\n  n — кількість бітів\n  X — число\n\nПояснення:\n*   Простою мовою: Це стандартний спосіб, яким комп'ютери представляють від'ємні числа, щоб можна було виконувати додавання і віднімання за допомогою одних і тих же схем.\n*   Професійно: Це формальне визначення доповняльного коду, який дозволяє представляти від'ємні числа в двійковій системі. Таке подання уніфікує арифметичні операції для знакових та беззнакових цілих чисел в АЛП."
  },
  "8": {
    "title": "Теорія складності. Класи складності. P vs NP?",
    "content": "Теорія обчислювальної складності — це розділ теорії обчислень, що класифікує задачі за кількістю ресурсів (час, пам'ять), необхідних для їх розв'язання за допомогою алгоритму.\nКласи складності — це множини задач, що мають схожу складність.\nКлас P (Polynomial): Містить задачі, які можна розв'язати за поліноміальний час на детермінованій машині Тюрінга. Це означає, що час роботи алгоритму T(n) обмежений поліномом від розміру вхідних даних n (наприклад, O(n²), O(n³)). Такі задачі вважаються \"ефективно розв'язуваними\".\nПриклади: Сортування масиву, пошук найкоротшого шляху в графі (алгоритм Дейкстри), знаходження найбільшого спільного дільника.\nКлас NP (Nondeterministic Polynomial): Містить задачі, для яких, якщо запропоновано розв'язок, його правильність можна перевірити за поліноміальний час. Це клас задач, які розв'язуються за поліноміальний час на недетермінованій машині Тюрінга.\nПриклади:\nЗадача комівояжера (TSP): Знайти найкоротший маршрут, що проходить через усі задані міста. Перевірка: якщо дано маршрут, дуже легко (за поліноміальний час) обчислити його довжину. Знаходження найкоротшого маршруту є дуже складним.\nЗадача про суму підмножини: Чи існує в множині чисел підмножина, сума якої дорівнює нулю? Перевірка: якщо дано підмножину, легко перевірити її суму.\nРозфарбування графу: Чи можна розфарбувати вершини графу в K кольорів так, щоб жодні дві суміжні вершини не мали однакового кольору?\nNP-повні задачі (NP-Complete): Це \"найскладніші\" задачі в класі NP. Вони мають дві властивості:\nВони належать до класу NP.\nБудь-яка інша задача з класу NP може бути зведена до них за поліноміальний час.\nЦе означає, що якщо знайдеться ефективний (поліноміальний) алгоритм для розв'язання хоча б однієї NP-повної задачі, то всі задачі з класу NP стануть ефективно розв'язуваними.\nПриклади: Задача комівояжера, задача здійсненності булевих формул (SAT).\nПроблема P vs NP:\nЦе одна з найважливіших відкритих проблем в математиці та комп'ютерних науках. Вона запитує: чи дорівнює клас P класу NP?\nЯкщо P = NP, це означатиме, що будь-яку задачу, розв'язок якої можна швидко перевірити, можна також і швидко знайти. Це мало б революційні наслідки: злам більшості сучасних криптосистем, вирішення складних оптимізаційних задач в логістиці, біології тощо.\nЯкщо P ≠ NP (як вважає більшість вчених), це означає, що існують задачі, які принципово складні для розв'язання, хоча їх розв'язок легко перевірити.\nНаразі доказу не існує, і за розв'язання цієї проблеми Інститут Клея пропонує премію в один мільйон доларів.",
    "formulas": "Класи складності:\n  P — задачі, розв’язувані за поліноміальний час\n  NP — задачі, для яких можна перевірити розв’язок за поліноміальний час\n\nP ?= NP — відкрите питання теорії складності\n\nПояснення:\n*   Простою мовою: P — це \"легкі\" задачі, які комп'ютер вирішує швидко. NP — це задачі, які може й важко вирішити, але якщо вам дадуть готову відповідь, її можна швидко перевірити. Головне питання — чи всі \"легко перевірювані\" задачі є також і \"легко вирішуваними\".\n*   Професійно: P і NP — фундаментальні класи складності в теорії обчислень. Рівність P і NP означала б, що для будь-якої задачі, розв'язок якої можна швидко перевірити, існує і швидкий алгоритм знаходження цього розв'язку."
  },
  "9": {
    "title": "Машина Тьюринга.",
    "content": "Машина Тьюринга — це абстрактна обчислювальна машина, запропонована Аланом Тьюрингом у 1936 році для формалізації поняття алгоритму. Вона є теоретичною моделлю комп'ютера з необмеженою пам'яттю і є фундаментальним поняттям в теорії обчислень.\nКомпоненти машини Тьюринга:\nНескінченна стрічка (Tape): Розділена на комірки, кожна з яких може містити один символ із скінченного алфавіту. Стрічка слугує пам'яттю.\nГолівка (Head): Може читати символ з поточної комірки, записувати новий символ в поточну комірку та переміщуватися на одну комірку вліво або вправо.\nКеруючий пристрій (Control Unit): Може перебувати в одному зі скінченної множини станів.\nТаблиця переходів (Transition Function): Програма для машини. Вона визначає, яку дію виконати, на основі поточного стану та символу, прочитаного зі стрічки. Дія складається з трьох частин:\nЗаписати новий символ у поточну комірку.\nПеремістити голівку (вліво, вправо або залишитись на місці).\nПерейти в новий стан.\nРобота машини:\nМашина починає роботу в початковому стані, з голівкою на першому символі вхідних даних. На кожному кроці вона виконує дію з таблиці переходів. Робота завершується, коли машина переходить в один зі спеціальних кінцевих (приймаючих або відхиляючих) станів. Результатом роботи є вміст стрічки на момент зупинки.\nТеза Черча-Тьюринга:\nЦе фундаментальне положення, яке стверджує, що будь-який алгоритм (у інтуїтивному розумінні) може бути реалізований на машині Тьюринга. Це означає, що якщо якусь задачу неможливо розв'язати на машині Тьюринга, то для неї не існує ефективного алгоритму взагалі.\nЗначення:\nТеоретична основа: Машина Тьюринга дозволяє строго визначити, що таке \"обчислення\" і що означає \"розв'язувана задача\" (та, для якої існує машина Тьюринга, що зупиняється).\nАналіз складності: Вона є еталоном для визначення класів складності (P, NP).\nДоказ нерозв'язуваності: Дозволила довести існування нерозв'язуваних задач, наприклад, проблеми зупинки (неможливо створити загальний алгоритм, який би визначав, чи зупиниться будь-яка задана програма).",
    "formulas": "Машина Тьюринга:\n  δ(q, a) = (q', a', d)\n\nде:\n  q, q' — стани\n  a — символ під головкою\n  a' — символ, що записується\n  d ∈ {L, R} — напрямок руху (ліворуч, праворуч)\n\nПояснення:\n*   Простою мовою: Це теоретична модель \"ідеального\" комп'ютера з нескінченною стрічкою пам'яті. Вона описує найпростіші кроки: прочитати, записати, змінити стан, зсунутися.\n*   Професійно: Формула описує функцію переходу машини Тьюринга. На основі поточного стану (q) і символу на стрічці (a) вона визначає наступний стан (q'), символ для запису (a') і напрямок руху головки (d)."
  },
  "10": {
    "title": "Технології віртуалізації.",
    "content": "Віртуалізація — це технологія створення віртуального (а не фізичного) представлення обчислювальних ресурсів, таких як сервер, настільний комп'ютер, сховище даних або мережа. Це дозволяє на одному фізичному обладнанні (хості) запускати кілька ізольованих віртуальних машин (гостей), кожна з яких працює зі своєю власною операційною системою.\nКлючовий компонент — гіпервізор (Hypervisor) або монітор віртуальних машин (VMM):\nЦе шар програмного забезпечення, який створює та запускає віртуальні машини. Він керує розподілом фізичних ресурсів (CPU, RAM, дисковий простір, мережеві інтерфейси) між гостьовими ОС.\nТипи гіпервізорів:\nТип 1 (Bare-metal): Гіпервізор встановлюється безпосередньо на \"залізо\" хоста. Він є, по суті, мінімалістичною ОС. Це забезпечує максимальну продуктивність та безпеку.\nПриклади: VMware ESXi, Microsoft Hyper-V, KVM (Kernel-based Virtual Machine) в Linux, Xen.\nВикористання: Дата-центри, хмарні провайдери.\nТип 2 (Hosted): Гіпервізор встановлюється як програма на існуючу повноцінну операційну систему (наприклад, Windows, macOS, Linux).\nПриклади: VMware Workstation, Oracle VirtualBox, Parallels Desktop.\nВикористання: Розробка, тестування, запуск ПЗ для інших ОС на локальному комп'ютері.\nОсновні види віртуалізації:\nВіртуалізація серверів: Найпоширеніший вид. Дозволяє консолідувати кілька фізичних серверів в один, зменшуючи витрати на обладнання, електроенергію та охолодження.\nВіртуалізація сховищ (Storage Virtualization): Об'єднання фізичних сховищ в єдиний логічний пул, що спрощує керування та розподіл дискового простору.\nВіртуалізація мереж (Network Virtualization): Створення віртуальних мереж (VLAN, VXLAN) поверх фізичної мережевої інфраструктури, що забезпечує ізоляцію та гнучкість.\nВіртуалізація робочих столів (VDI - Virtual Desktop Infrastructure): Запуск віртуальних десктопів на централізованому сервері, до яких користувачі підключаються з тонких клієнтів.\nКонтейнеризація (наприклад, Docker): Легковаговий вид віртуалізації на рівні ОС. Процеси запускаються в ізольованих середовищах (контейнерах), але використовують ядро хостової ОС. Це швидше та менш ресурсоємно, ніж повна віртуалізація.\nПереваги віртуалізації:\nЕфективне використання ресурсів.\nІзоляція: Проблеми в одній ВМ не впливають на інші.\nШвидке розгортання та міграція: Віртуальні машини можна легко копіювати, переміщувати між фізичними хостами (Live Migration).\nСпрощене резервне копіювання та відновлення: Створення \"знімків\" (snapshots) стану ВМ.\nСтворення тестових середовищ."
  },
  "11": {
    "title": "Хмарні сервіси.",
    "content": "Хмарні сервіси (Cloud Computing) — це модель надання обчислювальних ресурсів (серверів, сховищ, баз даних, мереж, ПЗ) через Інтернет (\"хмару\") за принципом \"оплати за використання\" (pay-as-you-go). Користувач отримує доступ до ресурсів на вимогу, не керуючи фізичною інфраструктурою, на якій вони працюють.\nОсновні моделі надання послуг:\nIaaS (Infrastructure as a Service — Інфраструктура як послуга):\nЩо надається: Базові обчислювальні ресурси: віртуальні машини, сховища, мережі.\nКористувач керує: Операційною системою, встановленим ПЗ, додатками.\nПровайдер керує: Фізичним обладнанням, віртуалізацією.\nПриклади: Amazon Web Services (AWS EC2), Google Compute Engine (GCE), Microsoft Azure VMs.\nPaaS (Platform as a Service — Платформа як послуга):\nЩо надається: Платформа для розробки, розгортання та керування додатками. Включає ОС, середовища виконання (наприклад, Java, Python), бази даних.\nКористувач керує: Своїми додатками та даними.\nПровайдер керує: Всією інфраструктурою нижчого рівня, включаючи ОС.\nПриклади: Heroku, Google App Engine, AWS Elastic Beanstalk.\nSaaS (Software as a Service — Програмне забезпечення як послуга):\nЩо надається: Готовий до використання додаток, доступний через веб-браузер або API.\nКористувач керує: Лише своїми даними в рамках додатку.\nПровайдер керує: Усім стеком технологій.\nПриклади: Google Workspace (Gmail, Docs), Microsoft 365, Salesforce, Dropbox.\nМоделі розгортання:\nПублічна хмара (Public Cloud): Інфраструктура належить провайдеру (AWS, Google, Azure) і доступна широкому загалу через Інтернет.\nПриватна хмара (Private Cloud): Інфраструктура використовується ексклюзивно однією організацією. Може бути розміщена як локально (on-premise), так і у провайдера.\nГібридна хмара (Hybrid Cloud): Комбінація публічної та приватної хмар, пов'язаних технологіями, що дозволяють переносити дані та додатки між ними.\nПереваги хмарних сервісів:\nЕкономія капітальних витрат: Немає потреби купувати власне обладнання.\nГнучкість та еластичність: Можливість швидко масштабувати ресурси вгору або вниз залежно від навантаження.\nГлобальна доступність: Доступ до сервісів з будь-якої точки світу.\nВисока надійність та доступність: Провайдери забезпечують резервування та географічний розподіл.\nШвидкість розгортання: Ресурси можна отримати за лічені хвилини."
  },
  "12": {
    "title": "Операційний автомат мікропроцесора.",
    "content": "Операційний автомат мікропроцесора — це частина керуючого пристрою (Control Unit) процесора, яка безпосередньо генерує послідовність мікрокоманд (керуючих сигналів) для виконання кожної машинної інструкції. Він реалізує логіку циклу Fetch-Decode-Execute.\nІснують два основних підходи до реалізації операційного автомата:\n\"Жорстка\" логіка (Hardwired Control Unit):\nРеалізація: Побудований на комбінаційних логічних схемах (дешифратори, логічні вентилі), які генерують керуючі сигнали безпосередньо з коду операції (opcode) інструкції та сигналів стану (прапорів).\nПереваги: Висока швидкість, оскільки сигнали генеруються за один такт.\nНедоліки: Складність проектування та модифікації. Якщо потрібно додати нову інструкцію, необхідно повністю перепроектувати апаратну логіку.\nЗастосування: RISC-процесори (Reduced Instruction Set Computer), де набір інструкцій простий та однорідний.\nМікропрограмне керування (Microprogrammed Control Unit):\nРеалізація: Кожна машинна інструкція інтерпретується послідовністю більш простих мікрокоманд. Ці мікрокоманди зберігаються в спеціальній швидкій пам'яті — мікропрограмному сховищі (Control Store), зазвичай ROM або Flash. Операційний автомат, по суті, є простим процесором, що виконує мікропрограми.\nПереваги:\nГнучкість: Легко додавати нові складні інструкції, просто додавши нову мікропрограму. Можна виправляти помилки в логіці процесора оновленням мікрокоду.\nСпрощення проектування: Дозволяє реалізувати дуже складні інструкції.\nНедоліки: Повільніше, ніж \"жорстка\" логіка, оскільки на виконання однієї машинної інструкції потрібно кілька тактів для вибірки та виконання мікрокоманд.\nЗастосування: CISC-процесори (Complex Instruction Set Computer), такі як x86. Сучасні x86 процесори часто використовують гібридний підхід: прості інструкції виконуються за допомогою \"жорсткої\" логіки, а складні — інтерпретуються мікропрограмним автоматом.",
    "formulas": "Операційний автомат мікропроцесора (стани):\n  Q = {Fetch, Decode, Execute, WriteBack, Idle}\n\nПояснення:\n*   Простою мовою: Це основні \"режими роботи\" процесора: отримати інструкцію, розшифрувати її, виконати, записати результат, а якщо робити нічого — відпочивати (Idle).\n*   Професійно: Це множина основних станів, через які проходить блок управління процесора (Control Unit) під час обробки кожної інструкції."
  },
  "13": {
    "title": "Цикл Fetch-Decode-eXecute.",
    "content": "Цикл Fetch-Decode-Execute (Вибірка-Декодування-Виконання) — це основний операційний цикл роботи центрального процесора. Це послідовність кроків, які процесор безперервно повторює для виконання машинних інструкцій програми.\nЕтапи циклу:\nFetch (Вибірка інструкції):\nПроцесор зчитує адресу наступної інструкції з регістра-лічильника команд (Program Counter, PC або Instruction Pointer, IP).\nЦя адреса виставляється на шину адрес.\nКонтролер пам'яті зчитує інструкцію за цією адресою з оперативної пам'яті.\nІнструкція передається по шині даних до процесора і завантажується в регістр інструкцій (Instruction Register, IR).\nЛічильник команд (PC) збільшується, щоб вказувати на наступну інструкцію.\nDecode (Декодування інструкції):\nКеруючий пристрій (Control Unit) аналізує інструкцію, що знаходиться в регістрі інструкцій (IR).\nВін визначає тип операції, яку потрібно виконати (наприклад, додавання, завантаження даних, перехід), ідентифікує операнди (дані або адреси даних), з якими потрібно працювати.\nНа цьому етапі генеруються відповідні керуючі сигнали для інших блоків процесора (АЛП, регістрів). У мікропрограмних процесорах на цьому етапі визначається адреса першої мікрокоманди відповідної мікропрограми.\nExecute (Виконання інструкції):\nКеруючі сигнали активують відповідні функціональні блоки процесора.\nВибірка операндів: Якщо інструкція потребує даних, вони зчитуються з регістрів або з пам'яті.\nВиконання операції: Арифметико-логічний пристрій (АЛП) виконує задану операцію (наприклад, додавання, порівняння).\nЗапис результату (Write-back): Результат операції записується назад у регістр або в оперативну пам'ять.\nОновлення прапорів: Регістр прапорів (Flags Register) оновлюється відповідно до результату операції (наприклад, встановлюється прапор нуля, прапор переносу).\nПісля завершення етапу виконання цикл починається знову з вибірки наступної інструкції. Цей процес триває до вимкнення живлення або отримання команди зупинки (HALT). Сучасні процесори ускладнюють цей цикл за допомогою конвеєризації та позачергового виконання, але фундаментальна логіка залишається тією ж.",
    "formulas": "Цикл Fetch-Decode-Execute:\n  IF: Instruction Fetch\n  ID: Instruction Decode\n  EX: Execute\n  MEM: Memory access\n  WB: Write Back\n\nПояснення:\n*   Простою мовою: Це конвеєр, як на заводі. Кожна інструкція проходить 5 етапів: вибірка, декодування, виконання, доступ до пам'яті, запис результату. Це дозволяє процесору працювати над кількома інструкціями одночасно.\n*   Професійно: Це класична п'ятиступенева модель конвеєра (pipeline) в RISC-архітектурах. Вона дозволяє досягти паралелізму на рівні інструкцій, значно підвищуючи продуктивність процесора."
  },
  "14": {
    "title": "Класифікації мікропроцесорів за архітектурою команд.",
    "content": "Архітектура набору команд (Instruction Set Architecture, ISA) визначає набір інструкцій, які процесор може розуміти та виконувати. Це основний інтерфейс між програмним та апаратним забезпеченням.\nОсновні класифікації:\nCISC (Complex Instruction Set Computer — Комп'ютер зі складним набором команд):\nФілософія: Надати програмісту/компілятору потужні, високорівневі інструкції, кожна з яких може виконувати складну операцію (наприклад, зчитати два операнди з пам'яті, додати їх і записати результат назад у пам'ять — все однією командою).\nХарактеристики:\nВелика кількість інструкцій.\nІнструкції різної довжини та формату.\nБагато режимів адресації.\nРеалізація зазвичай мікропрограмна.\nПереваги: Компактний код (одна інструкція робить багато роботи), спрощення роботи для програміста на асемблері.\nНедоліки: Складний декодер інструкцій, ускладнена конвеєризація, не всі інструкції використовуються часто.\nПриклади: Intel x86, AMD64, IBM System/360.\nRISC (Reduced Instruction Set Computer — Комп'ютер зі скороченим набором команд):\nФілософія: Спростити набір інструкцій до мінімуму, щоб кожну інструкцію можна було виконати дуже швидко (в ідеалі за один такт). Складні операції реалізуються послідовністю простих інструкцій.\nХарактеристики:\nМала кількість простих інструкцій.\nІнструкції фіксованої довжини та формату.\nОперації переважно виконуються над регістрами (архітектура \"load-store\": дані завантажуються з пам'яті в регістри, обробляються, результат записується назад у пам'ять окремими командами).\nРеалізація на \"жорсткій\" логіці.\nВелика кількість регістрів загального призначення.\nПереваги: Простий декодер, ефективна конвеєризація, висока тактова частота.\nНедоліки: Більший розмір коду, оскільки складні операції потребують більше інструкцій.\nПриклади: ARM, MIPS, PowerPC, SPARC, RISC-V.\nVLIW (Very Long Instruction Word — Дуже довге командне слово):\nФілософія: Перенести частину роботи з розпаралелювання інструкцій з апаратного забезпечення на компілятор. В одній довгій інструкції закодовано кілька незалежних операцій, які процесор може виконати одночасно на різних функціональних пристроях (АЛП, FPU тощо).\nПриклади: Intel Itanium (частково), деякі DSP-процесори (Digital Signal Processor).\nMISC (Minimal Instruction Set Computer):\nЕкстремальна форма RISC з дуже малою кількістю інструкцій.\nСучасний стан: Межі між CISC та RISC розмиті. Сучасні CISC-процесори (наприклад, Intel Core) всередині мають RISC-подібне ядро. Складні x86 інструкції на етапі декодування розбиваються на простіші внутрішні мікрооперації (μops), які потім виконуються конвеєрним RISC-ядром."
  },
  "15": {
    "title": "Комбінаційна логіка.",
    "content": "Комбінаційна логіка (Combinational Logic) — це тип цифрових логічних схем, в яких вихідні сигнали в будь-який момент часу залежать виключно від поточних значень вхідних сигналів. Комбінаційні схеми не мають пам'яті, тобто вони не зберігають інформацію про попередні стани.\nОсновні характеристики:\nВідсутність зворотних зв'язків: Вихід схеми не подається назад на її вхід (на відміну від послідовнісної логіки).\nВідсутність пам'яті: Результат не залежить від попередньої історії вхідних сигналів.\nМатематичний опис: Функціонування комбінаційної схеми повністю описується булевою функцією або таблицею істинності.\nБазові елементи (логічні вентилі):\nAND (І): Вихід \"1\" тільки якщо всі входи \"1\".\nOR (АБО): Вихід \"1\" якщо хоча б один вхід \"1\".\nNOT (НЕ, інвертор): Вихід є інверсією входу.\nNAND (І-НЕ): Інверсія AND.\nNOR (АБО-НЕ): Інверсія OR.\nXOR (Виключне АБО): Вихід \"1\" якщо входи різні.\nПриклади комбінаційних схем:\nШифратори (Encoders): Перетворюють активний вхідний сигнал (з 2^n входів) в n-бітний двійковий код.\nДешифратори (Decoders): Перетворюють n-бітний двійковий код в активний сигнал на одному з 2^n виходів. Використовуються для вибору адреси пам'яті.\nМультиплексори (Multiplexers, MUX): Вибирають один з кількох вхідних сигналів і передають його на єдиний вихід. Вибір здійснюється за допомогою керуючих сигналів. Це \"електронний перемикач\".\nДемультиплексори (Demultiplexers, DEMUX): Виконують зворотну функцію: передають сигнал з одного входу на один з кількох виходів, який вибирається керуючими сигналами.\nСуматори (Adders): Виконують арифметичне додавання двійкових чисел.\nНапівсуматор (Half Adder): Додає два біти, видає суму та перенесення.\nПовний суматор (Full Adder): Додає три біти (два операнди і перенесення з попереднього розряду), видає суму та перенесення.\nКомпаратори (Comparators): Порівнюють два двійкових числа і видають сигнал, що вказує, чи є вони рівними, або яке з них більше.\nКомбінаційні схеми є будівельними блоками для більш складних цифрових пристроїв, включаючи арифметико-логічний пристрій (АЛП) та керуючі пристрої в процесорах.",
    "formulas": "Комбінаційна логіка:\n  Y = f(X1, X2, ..., Xn)\n\nПояснення:\n*   Простою мовою: Вихід такої схеми залежить *тільки* від поточних входів, у неї немає пам'яті. Приклад: калькулятор, який показує результат лише коли ви натискаєте на кнопки.\n*   Професійно: Це математичне представлення комбінаційної схеми, де вихідні сигнали (Y) є булевою функцією (f) від поточних вхідних сигналів (X)."
  },
  "16": {
    "title": "Синтез з використанням ROM, булевої мінімізації, деморганізації, мультиплексорів.",
    "content": "Синтез логічної схеми — це процес проектування та побудови цифрової схеми, яка реалізує задану логічну функцію або поведінку.\nЗасоби синтезу:\nБулева мінімізація:\nМета: Спростити булеву функцію до її мінімальної форми (наприклад, диз'юнктивної нормальної форми - ДНФ, або кон'юнктивної нормальної форми - КНФ). Це дозволяє реалізувати схему з меншою кількістю логічних вентилів, що зменшує її вартість, розмір та енергоспоживання.\nМетоди:\nКарти Карно (Karnaugh Maps): Графічний метод для функцій з невеликою кількістю змінних (до 4-5).\nМетод Куайна-Мак-Класкі: Табличний, алгоритмічний метод, який можна автоматизувати для функцій з більшою кількістю змінних.\nДеморганізація:\nМета: Перетворити логічну схему для реалізації на базі конкретного типу вентилів, зазвичай NAND (І-НЕ) або NOR (АБО-НЕ), оскільки вони є універсальними (будь-яку булеву функцію можна реалізувати тільки на них).\nПроцес: Використання законів де Моргана для перетворення виразів:\n¬(A ∧ B) ⇔ ¬A ∨ ¬B\n¬(A ∨ B) ⇔ ¬A ∧ ¬B\nНаприклад, функцію F = A ∧ B можна реалізувати як ¬(¬(A ∧ B)), що є двома послідовними NAND вентилями.\nСинтез з використанням мультиплексорів (MUX):\nМета: Реалізувати довільну булеву функцію від N змінних за допомогою мультиплексора.\nПроцес: Для функції від N змінних можна використати мультиплексор з N-1 керуючими входами та 2^(N-1) інформаційними входами. Змінні x₁, ..., x_(N-1) подаються на керуючі входи. На кожен інформаційний вхід Dᵢ подається або 0, 1, xₙ, або ¬xₙ залежно від значень функції для відповідної комбінації керуючих входів. Це потужний та систематичний метод синтезу.\nСинтез з використанням ROM (Read-Only Memory — Постійний запам'ятовуючий пристрій):\nМета: Реалізувати набір логічних функцій. ROM можна розглядати як універсальний комбінаційний пристрій.\nПроцес:\nВхідні змінні функції (n штук) подаються на адресні входи ROM.\nROM має 2^n комірок пам'яті.\nУ кожній комірці пам'яті заздалегідь записується значення функції для відповідної комбінації вхідних змінних.\nКоли на адресні входи подається певна комбінація, ROM видає на вихід даних вміст відповідної комірки.\nПереваги: Простота проектування (потрібно лише заповнити таблицю істинності та \"прошити\" її в ROM), можливість реалізації дуже складних функцій.\nНедоліки: Повільніше, ніж схеми на вентилях, може бути неефективним для простих функцій.\n(Питання 17 пропущено у списку)",
    "formulas": "Синтез з ROM:\n  Y = ROM(Address)\n\nБулева мінімізація, правила Де Моргана:\n  ¬(A · B) = ¬A + ¬B\n  ¬(A + B) = ¬A · ¬B\n\nМультиплексор:\n  Y = S · A + ¬S · B\n\nПояснення:\n*   Простою мовою: Правила Де Моргана — це \"хитрість\" для спрощення логічних виразів. Мультиплексор — це перемикач, який вибирає один з кількох входів (A або B) і передає його на вихід (Y) залежно від сигналу керування (S).\n*   Професійно: Правила Де Моргана є ключовими для перетворення та мінімізації булевих функцій. Мультиплексор (MUX) — це комбінаційний пристрій, що реалізує функцію вибору одного з 2^N входів на основі N керуючих сигналів."
  },
  "18": {
    "title": "Тактування. Двоступінчатий тригер.",
    "content": "Тактування (Clocking) — це процес синхронізації роботи цифрових послідовнісних схем за допомогою спеціального сигналу, який називається тактовим сигналом (clock signal). Тактовий сигнал — це періодична послідовність імпульсів (зміни 0→1 та 1→0), яка задає темп роботи системи. Всі зміни станів у синхронних схемах відбуваються узгоджено, зазвичай по фронту (rising edge, 0→1) або по спаду (falling edge, 1→0) тактового сигналу.\nПризначення тактування:\nСинхронізація: Забезпечує одночасну та узгоджену роботу всіх елементів схеми (тригерів, регістрів).\nУсунення \"гонок\" (Race Conditions): Запобігає ситуаціям, коли результат роботи схеми залежить від того, який з сигналів прийде першим, що могло б призвести до непередбачуваної поведінки.\nДвоступінчатий тригер (Master-Slave Flip-Flop):\nЦе тип тригера, побудований для вирішення проблеми прозорості (transparency) простих тригерів, що тактуються рівнем. Проблема полягає в тому, що поки тактовий сигнал активний (наприклад, = 1), вхід тригера \"прозорий\" для виходу, і будь-які зміни на вході одразу ж передаються на вихід, що може викликати нестабільність у складних схемах зі зворотними зв'язками.\nСтруктура та принцип роботи:\nДвоступінчатий тригер складається з двох послідовно з'єднаних тригерів:\nВедучий (Master): Перший тригер.\nВедений (Slave): Другий тригер.\nТактовий сигнал подається на ведучий тригер безпосередньо, а на ведений — через інвертор.\nКрок 1 (Тактовий сигнал = 1, фаза \"захоплення\"):\nВедучий тригер (Master) стає \"прозорим\" і приймає (захоплює) значення з інформаційного входу (D).\nВедений тригер (Slave) відключений від ведучого (оскільки на його тактовий вхід подається інвертований сигнал, тобто 0) і зберігає свій попередній стан. Вихід всього пристрою не змінюється.\nКрок 2 (Тактовий сигнал = 0, фаза \"передачі\"):\nВедучий тригер \"закривається\" і фіксує значення, яке він захопив на попередньому кроці. Він більше не реагує на зміни на вході D.\nВедений тригер стає \"прозорим\", приймає значення з виходу ведучого тригера і передає його на вихід всього пристрою.\nРезультат: Зміна на виході двоступінчастого тригера відбувається тільки один раз за такт, по спаду тактового сигналу (1→0). Це забезпечує стабільну та передбачувану роботу в синхронних системах. Тригери, що спрацьовують по фронту (edge-triggered), є більш сучасною альтернативою, яка вирішує ту ж проблему, але є більш ефективною.",
    "formulas": "Двоступінчатий тригер (RS-тригер):\n  Q_next = S + ¬R · Q\n\nПояснення:\n*   Простою мовою: Це найпростіший елемент пам'яті на один біт. Сигнал S (Set) встановлює його в 1, а сигнал R (Reset) — в 0.\n*   Професійно: Це характеристичне рівняння асинхронного RS-тригера (або SR-латча), яке описує його наступний стан (Q_next) залежно від входів S, R та поточного стану (Q)."
  },
  "19": {
    "title": "Послідовність встановлення значення D-тригеру.",
    "content": "D-тригер (Delay Flip-Flop) — це базовий елемент послідовнісної логіки, який слугує для зберігання одного біта інформації. Його основна властивість — на виході Q після тактового імпульсу встановлюється те значення, яке було на вході D безпосередньо перед цим імпульсом.\nСинхронний D-тригер, що спрацьовує по фронту (Rising-Edge Triggered D-Flip-Flop):\nЦе найпоширеніший тип. Він має два входи:\nD (Data) — інформаційний вхід.\nCLK (Clock) — тактовий вхід.\nІ один основний вихід:\nQ — вихід, що зберігає стан.\nПослідовність встановлення значення:\nПідготовка даних (Setup Time): Значення, яке потрібно записати в тригер, повинно бути подано на вхід D і залишатися стабільним протягом певного мінімального часу до приходу активного фронту тактового сигналу. Цей час називається часом встановлення (setup time, t_su). Це необхідно, щоб внутрішні логічні елементи тригера встигли стабілізуватися.\nАктивний фронт тактового сигналу (Clock Edge): Коли на вхід CLK надходить наростаючий фронт (перехід з 0 на 1), тригер \"захоплює\" значення, що знаходиться на вході D.\nУтримання даних (Hold Time): Значення на вході D повинно залишатися стабільним ще протягом певного мінімального часу після приходу активного фронту. Цей час називається часом утримання (hold time, t_h). Це гарантує, що тригер надійно зафіксував правильне значення.\nОновлення виходу (Propagation Delay): Після активного фронту і закінчення часу утримання, через невелику затримку, яка називається часом розповсюдження (propagation delay, t_pd), нове значення з'являється на виході Q.\nПідсумок послідовності:\nНа вхід D подається біт даних.\nДані стабілізуються на вході D (виконується вимога t_su).\nПриходить активний фронт сигналу CLK.\nДані утримуються на вході D (виконується вимога t_h).\nЧерез t_pd вихід Q приймає значення, яке було на вході D.\nЯкщо вимоги до t_su або t_h порушені, тригер може увійти в метастабільний стан, коли його вихід невизначений протягом деякого часу, що є серйозною помилкою в цифрових схемах.",
    "formulas": "Послідовність встановлення D-тригера:\n  Q_next = D\n\nПояснення:\n*   Простою мовою: Це більш сучасний елемент пам'яті. Він просто запам'ятовує те значення (D), яке було на вході в момент подачі тактового імпульсу.\n*   Професійно: Характеристичне рівняння синхронного D-тригера. Воно показує, що при надходженні активного фронту тактового сигналу вихід Q приймає значення входу D, що робить його ідеальним елементом для регістрів."
  },
  "20": {
    "title": "Регістри.",
    "content": "Регістр — це послідовнісний логічний пристрій, що являє собою групу з'єднаних тригерів, призначений для зберігання, зсуву та обробки багаторозрядного двійкового слова (наприклад, байта, машинного слова). Кожен тригер в регістрі зберігає один біт інформації.\nОсновні функції та типи регістрів:\nРегістри зберігання (Storage Registers / Latches):\nПризначення: Просто зберігати двійкове слово.\nПринцип роботи: Дані записуються в усі тригери одночасно по спільному тактовому сигналу і зберігаються до наступного запису.\nЗастосування: Регістри загального призначення в CPU (EAX, EBX...), регістр інструкцій, буферні регістри.\nЗсувні регістри (Shift Registers):\nПризначення: Зсувати біти слова вліво або вправо на одну або кілька позицій за кожен тактовий імпульс.\nПринцип роботи: Вихід одного тригера з'єднаний з входом наступного.\nТипи за способом завантаження/вивантаження даних:\nSISO (Serial-In, Serial-Out): Послідовне завантаження, послідовне вивантаження. Використовується для затримки сигналів.\nSIPO (Serial-In, Parallel-Out): Послідовне завантаження, паралельне вивантаження. Застосування: Перетворення послідовного потоку даних (наприклад, з UART) в паралельне слово.\nPISO (Parallel-In, Serial-Out): Паралельне завантаження, послідовне вивантаження. Застосування: Перетворення паралельного слова (з шини даних) в послідовний потік.\nPIPO (Parallel-In, Parallel-Out): Паралельне завантаження, паралельне вивантаження. По суті, це регістр зберігання.\nЗастосування: Апаратна реалізація множення та ділення на степені двійки, перетворення даних, генерація псевдовипадкових послідовностей.\nЛічильники (Counters):\nПризначення: Спеціалізовані регістри, стан яких змінюється за певним законом з кожним тактовим імпульсом (наприклад, збільшується на 1).\nПринцип роботи: Використовуються тригери (часто T-тригери або JK-тригери), з'єднані так, щоб реалізувати логіку лічби.\nЗастосування: Лічильник команд (Program Counter) в CPU, таймери, дільники частоти.\nРегістри є ключовими компонентами будь-якого процесора, забезпечуючи надзвичайно швидкий доступ до даних, необхідних для поточних обчислень."
  },
  "21": {
    "title": "Арифметично-логічний пристрій.",
    "content": "Арифметично-логічний пристрій (АЛП, англ. ALU - Arithmetic Logic Unit) — це центральний блок цифрової обробки в мікропроцесорі, який виконує арифметичні та логічні операції над операндами (двійковими числами).\nСтруктура та входи/виходи:\nВходи:\nДва входи для операндів (A та B), які зазвичай надходять з регістрів загального призначення.\nВхід для коду операції (Opcode), що надходить від керуючого пристрою і вказує, яку операцію виконати (додавання, І, АБО тощо).\nВхід перенесення (Carry-in) з попереднього розряду (для багаторозрядних операцій).\nВиходи:\nВихід результату операції (Result).\nВихід перенесення (Carry-out) для наступного розряду.\nВиходи прапорів (Flags), які характеризують результат операції.\nОсновні операції, що виконуються АЛП:\nАрифметичні операції:\nДодавання (ADD): Основна операція, реалізована на базі суматорів.\nВіднімання (SUB): Зазвичай реалізується як додавання з доповняльним кодом другого операнда.\nІнкремент (INC): Збільшення на 1.\nДекремент (DEC): Зменшення на 1.\nМноження (MUL) та Ділення (DIV): У простих АЛП реалізуються послідовністю додавань/зсувів. У складних процесорах для цього є окремі апаратні блоки.\nЛогічні операції (побітові):\nAND (Логічне І): Result[i] = A[i] AND B[i]\nOR (Логічне АБО): Result[i] = A[i] OR B[i]\nXOR (Виключне АБО): Result[i] = A[i] XOR B[i]\nNOT (Інверсія): Result[i] = NOT A[i]\nОперації зсуву:\nЛогічний зсув (SHL/SHR): Зсув бітів вліво/вправо, вільні позиції заповнюються нулями.\nАрифметичний зсув (SAL/SAR): При зсуві вправо знаковий біт копіюється, зберігаючи знак числа.\nЦиклічний зсув (ROL/ROR): Біт, що виштовхується з одного кінця, з'являється на іншому.\nПрапори (Flags):\nАЛП також генерує прапори, які зберігаються в спеціальному регістрі прапорів (наприклад, EFLAGS в x86) і використовуються для реалізації умовних переходів:\nZero Flag (ZF): Встановлюється в 1, якщо результат операції дорівнює нулю.\nSign Flag (SF): Копіює знаковий біт результату (1, якщо результат від'ємний).\nCarry Flag (CF): Встановлюється в 1, якщо відбулося перенесення/позика зі старшого розряду.\nOverflow Flag (OF): Встановлюється в 1, якщо відбулося арифметичне переповнення при операціях з числами зі знаком.\nАЛП є \"серцем\" обчислювальної частини процесора, виконуючи основну роботу з обробки даних.",
    "formulas": "Арифметично-логічний пристрій (ALU):\n  Сума: S = A + B\n  AND: R = A & B\n  OR:  R = A | B\n  NOT: R = ¬A\n\nПояснення:\n*   Простою мовою: Це \"мозок-калькулятор\" всередині процесора. Він виконує всі математичні (додавання) та логічні (І, АБО, НЕ) операції.\n*   Професійно: АЛП — це цифровий комбінаційний пристрій у складі процесора, що виконує арифметичні та побітові логічні операції над операндами."
  },
  "22": {
    "title": "Алгоритми множення цілих чисел.",
    "content": "Апаратна реалізація множення є складнішою за додавання. Існують різні алгоритми, що балансують між швидкістю та складністю апаратної реалізації.\n\"Шкільний\" метод (Зсув та додавання):\nПринцип: Аналогічний множенню \"в стовпчик\". Множник розглядається побітово. Якщо поточний біт множника дорівнює 1, множене додається до проміжного результату. Після кожного кроку множене зсувається вліво (або проміжний результат зсувається вправо).\nАлгоритм (для беззнакових чисел):\nІніціалізувати регістр результату нулем.\nПовторити N разів (де N — розрядність чисел):\na. Перевірити молодший біт множника.\nb. Якщо біт = 1, додати множене до результату.\nc. Зсунути множене на 1 біт вліво.\nd. Зсунути множник на 1 біт вправо.\nНедоліки: Повільний, вимагає N ітерацій.\nАлгоритм Бута (Booth's Algorithm):\nПризначення: Ефективний алгоритм для множення чисел зі знаком у доповняльному коді.\nПринцип: Аналізує не один, а два сусідні біти множника на кожному кроці. Це дозволяє пропускати послідовності одиниць, виконуючи лише одне додавання на початку послідовності та одне віднімання в кінці.\nДії залежно від пари бітів (поточний Qᵢ та попередній Qᵢ₋₁):\n00 або 11: Нічого не робити, просто арифметичний зсув.\n01: Додати множене до результату.\n10: Відняти множене від результату.\nПереваги: Швидший за простий зсув-додавання для чисел з довгими послідовностями одиниць або нулів. Добре працює з від'ємними числами.\nМатричний помножувач (Array Multiplier):\nПринцип: Комбінаційна схема, що реалізує множення за один такт. Складається з матриці повних суматорів та вентилів AND.\nСтруктура: Для множення N-бітного числа на M-бітне потрібно N * M вентилів AND та масив суматорів. Кожен вентиль AND обчислює частковий добуток (Aᵢ * Bⱼ), а суматори складають ці часткові добутки.\nПереваги: Дуже висока швидкість (результат готовий після затримки розповсюдження сигналу через схему).\nНедоліки: Дуже велика апаратна складність, займає багато місця на кристалі.\nДерево Уоллеса (Wallace Tree):\nПринцип: Більш ефективний метод комбінаційного множення. Замість послідовного додавання часткових добутків, він використовує каскад суматорів для паралельного зведення багатьох часткових добутків до двох чисел, які потім складаються фінальним швидким суматором.\nПереваги: Швидший за матричний помножувач, оскільки має логарифмічну глибину затримки.\nЗастосування: Використовується в сучасних високопродуктивних процесорах.",
    "formulas": "Алгоритм множення цілих чисел:\n  Результат = 0\n  для i в [0..n-1]:\n    якщо B[i] == 1:\n      Результат += A << i\n\nПояснення:\n*   Простою мовою: Це двійковий аналог \"множення у стовпчик\". Алгоритм перевіряє кожен біт другого числа, і якщо це 1, додає до результату перше число, зсунуте на відповідну кількість позицій.\n*   Професійно: Псевдокод описує базовий алгоритм множення \"зсув-додавання\". Він ітерує по бітах множника (B) і акумулює суму зсунутих значень множимого (A)."
  },
  "23": {
    "title": "Архітектура IBM Mainframe.",
    "content": "Мейнфрейм (Mainframe) — це клас високопродуктивних, надійних та масштабованих комп'ютерів, що використовуються великими організаціями (банками, урядами, корпораціями) для критично важливих додатків, які потребують обробки величезних об'ємів транзакцій та даних. Архітектура IBM Mainframe (зараз IBM Z) є еталоном у цьому класі.\nКлючові принципи та особливості архітектури:\nЗворотна сумісність (Backward Compatibility): Один з найважливіших принципів. Програми, написані для IBM System/360 у 1960-х роках, можуть (з мінімальними змінами або без них) працювати на сучасних системах IBM Z. Це забезпечує захист інвестицій у програмне забезпечення.\nНадійність, доступність та обслуговуваність (RAS - Reliability, Availability, Serviceability):\nНадійність: Використання надлишкових компонентів (процесори, блоки живлення, шляхи вводу/виводу), ECC-пам'яті, можливості самодіагностики та виправлення помилок.\nДоступність: Здатність системи працювати безперервно (часто 99.999% uptime). Компоненти можна замінювати \"на гарячу\" (hot-swapping) без зупинки системи.\nОбслуговуваність: Системи розроблені для легкого діагностування та ремонту.\nЦентралізована обробка з потужним вводом/виводом (I/O):\nНа відміну від розподілених систем, мейнфрейми зосереджені на централізованій обробці.\nКанальна підсистема вводу/виводу: Обробка операцій I/O винесена на спеціалізовані співпроцесори (канали або процесори вводу/виводу), які працюють незалежно від центральних процесорів. Це дозволяє CPU займатися обчисленнями, поки I/O процесори керують передачею даних, що є критичним для транзакційних систем.\nМасштабованість:\nВертикальна (Scale-up): Можливість додавати процесори, пам'ять, канали I/O в рамках однієї фізичної системи.\nГоризонтальна (Scale-out): Технологія Parallel Sysplex дозволяє об'єднати до 32 мейнфреймів в єдиний кластер, що виглядає як одна система для додатків. Це забезпечує майже лінійне масштабування та надвисоку доступність.\nВіртуалізація: IBM була піонером віртуалізації. Їхня операційна система z/VM дозволяє запускати тисячі віртуальних машин (Linux, z/OS) на одному фізичному мейнфреймі. Технологія логічних розділів (LPAR) дозволяє апаратно розділити один мейнфрейм на кілька незалежних віртуальних серверів.\nБезпека: Архітектура має вбудовані апаратні засоби для криптографії (крипто-співпроцесори) та логічного розділення, що забезпечує дуже високий рівень безпеки.\nОпераційні системи: z/OS (основна транзакційна ОС), z/VM (гіпервізор), z/VSE та Linux on IBM Z.\nСучасне застосування: Банківські транзакції, системи бронювання квитків, страхові компанії, ERP-системи, тобто скрізь, де потрібна обробка мільйонів транзакцій на добу з максимальною надійністю."
  },
  "24": {
    "title": "Компоненти материнської плати комп'ютера. Функції чіпсету.",
    "content": "Материнська плата (Motherboard) — це основна друкована плата комп'ютерної системи, яка об'єднує та забезпечує взаємодію всіх ключових компонентів комп'ютера.\nОсновні компоненти материнської плати:\nСокет процесора (CPU Socket): Роз'єм для встановлення центрального процесора.\nЧіпсет (Chipset): Набір мікросхем, що керує потоками даних між процесором, пам'яттю та периферійними пристроями.\nСлоти для оперативної пам'яті (RAM Slots): Роз'єми для встановлення модулів пам'яті (DIMM).\nСлоти розширення (Expansion Slots):\nPCI Express (PCIe): Сучасний високошвидкісний інтерфейс для відеокарт, SSD, мережевих карт.\nPCI (застарілий): Для старих карт розширення.\nРоз'єми для накопичувачів:\nSATA (Serial ATA): Для підключення жорстких дисків (HDD) та твердотільних накопичувачів (SSD).\nM.2: Компактний роз'єм для високошвидкісних NVMe SSD.\nМікросхема BIOS/UEFI: Flash-пам'ять, що містить базову систему вводу-виводу (BIOS) або її сучасний аналог (UEFI), яка ініціалізує обладнання при старті комп'ютера.\nБатарейка CMOS: Живить мікросхему CMOS RAM для збереження налаштувань BIOS/UEFI та системного часу.\nСистема живлення (VRM - Voltage Regulator Module): Перетворює напругу з блоку живлення в стабільну напругу, необхідну для процесора.\nЗадня панель роз'ємів (I/O Panel): Порти USB, Ethernet (RJ-45), аудіо роз'єми, відео виходи (HDMI, DisplayPort) тощо.\nВнутрішні роз'єми (Headers): Для підключення USB-портів корпусу, аудіо-панелі, кнопок живлення та індикаторів.\nФункції чіпсету:\nЧіпсет — це \"нервова система\" материнської плати. Історично він складався з двох мікросхем:\nПівнічний міст (Northbridge): Відповідав за високошвидкісні комунікації: зв'язок між CPU, RAM та слотом для відеокарти (AGP/PCIe).\nПівденний міст (Southbridge): Відповідав за повільніші периферійні пристрої: слоти PCI, порти SATA, USB, аудіо, мережевий контролер, BIOS.\nСучасна архітектура:\nУ сучасних системах (починаючи з Intel Nehalem та AMD Zen) функції північного мосту (контролер пам'яті, контролер PCIe) інтегровані безпосередньо в кристал центрального процесора. Це значно зменшує затримки при доступі до пам'яті та підвищує продуктивність.\nЧіпсет тепер складається з однієї мікросхеми, яка називається PCH (Platform Controller Hub) в системах Intel або просто Chipset в AMD.\nФункції сучасного чіпсета (PCH):\nКерування портами SATA та USB.\nНадання додаткових ліній PCI Express для периферійних пристроїв (крім тих, що підключені напряму до CPU).\nІнтегрований мережевий контролер (MAC).\nІнтегрований аудіокодек.\nЗв'язок з мікросхемою BIOS/UEFI.\nКерування системним часом (RTC).\nЗабезпечення зв'язку між усіма цими пристроями та центральним процесором через спеціальну шину (наприклад, DMI у Intel, PCIe у AMD).\nОтже, чіпсет визначає функціональність материнської плати: кількість і версії портів USB, SATA, ліній PCIe, підтримку RAID та інших технологій."
  },
  "25": {
    "title": "Архітектура сучасних мікропроцесорів",
    "content": "Сучасні мікропроцесори — це високотехнологічні пристрої, побудовані на основі мільярдів транзисторів, що об'єднані в складні логічні структури. Їх архітектура поєднує в собі апаратні й мікропрограмні засоби для ефективного виконання інструкцій. Архітектурно мікропроцесори можуть реалізовувати або RISC (з акцентом на прості інструкції й високу тактову частоту), або CISC (з більшою кількістю складних інструкцій, що економлять пам’ять).\n\nКлючові особливості:\n\nМультикорність дозволяє досягти паралелізму на рівні потоків — кожне ядро працює над окремим завданням, підвищуючи загальну продуктивність системи.\n\nКонвеєризація забезпечує ефективне використання виконавчих блоків за рахунок поділу виконання інструкцій на фази.\n\nСуперскалярна архітектура дає змогу виконувати кілька інструкцій за такт, що значно підвищує швидкодію.\n\nГіперпоточність (Hyper-Threading) — технологія, яка дозволяє одному фізичному ядру працювати як два логічні, підвищуючи навантаження і ефективність.\n\nКеш-пам’ять кількох рівнів (L1, L2, L3) — критично важлива для мінімізації затримок доступу до пам’яті.\n\nАпаратна віртуалізація дозволяє ефективно запускати декілька операційних систем або ізольованих середовищ.\n\nЕнергозберігаючі технології (наприклад, Intel SpeedStep або AMD Cool'n'Quiet) забезпечують баланс між продуктивністю й енергоспоживанням.\n\nКрім того, важливе значення має архітектура інтерконекту (QPI, AMD Infinity Fabric), яка визначає швидкість обміну між ядрами, кешами, пам’яттю та периферією."
  },
  "26": {
    "title": "Основні компоненти мікропроцесора",
    "content": "Мікропроцесор містить низку логічних блоків, які працюють у тісній взаємодії:\n\nАЛП (ALU) — обробляє базові арифметичні й логічні операції; є центральним виконавчим елементом.\n\nБлок управління (CU) — декодує інструкції та координує взаємодію компонентів.\n\nРегістрів — внутрішні швидкодіючі сховища. Розрізняють регістри загального призначення, спеціального призначення та службові.\n\nКеш-пам’ять — розташована між процесором і RAM, мінімізує час доступу до часто використовуваних даних.\n\nШини — передають дані, адреси та сигнали керування (системна шина, адресна, керуюча).\n\nТактовий генератор — задає ритм роботи процесора.\n\nМодуль роботи з пам’яттю — забезпечує адресацію, кешування та узгодження доступу до RAM.\n\nДекодер інструкцій — аналізує машинні коди й формує сигнали керування.\n\nСукупність цих компонентів забезпечує реалізацію циклу виконання інструкції: вибірка, декодування, виконання, запис результату."
  },
  "27": {
    "title": "Конвеєр",
    "content": "Конвеєр у процесорах — це реалізація принципу накладення операцій: одна інструкція виконується в той час, коли інша декодується, а ще одна вибирається з пам’яті. Це суттєво підвищує інструкційну пропускну здатність (Instruction Throughput).\n\nТипові етапи (5-стадійний конвеєр):\n\nIF (Instruction Fetch) — завантаження інструкції.\n\nID (Instruction Decode) — декодування й підготовка до виконання.\n\nOF (Operand Fetch) — зчитування операндів.\n\nEX (Execute) — виконання інструкції.\n\nWB (Write Back) — запис результату.\n\nНедоліки:\n\nКонфлікти (hazards):\n\nData hazard — залежність між інструкціями.\n\nControl hazard — при переходах.\n\nStructural hazard — апаратна нестача ресурсів.\n\nРозв’язуються за допомогою:\n\nдинамічного перескладання (out-of-order execution),\n\nбуферів (реєстрів повтору),\n\nспекулятивного виконання та предикції переходів.",
    "formulas": "Конвеєрна обробка інструкцій:\n  Стадії: IF → ID → EX → MEM → WB\n\nПояснення:\n*   Простою мовою: Процесор не чекає, доки одна інструкція повністю завершиться, а починає обробляти наступну, як тільки звільняється перший етап \"конвеєра\". Це значно прискорює роботу.\n*   Професійно: Це візуалізація п'ятистадійного конвеєра, що ілюструє послідовність етапів обробки інструкції для досягнення інструкційного паралелізму."
  },
  "28": {
    "title": "Архітектура набору команд EM64T. Основні групи операцій",
    "content": "EM64T — це 64-бітне розширення архітектури x86, також відоме як Intel 64. Воно дозволяє процесору працювати з 64-бітними операндами й адресами, що забезпечує підтримку великої обсягу оперативної пам’яті (понад 4 ГБ).\n\nОсновні групи інструкцій:\n\nАрифметико-логічні операції: ADD, SUB, MUL, DIV, AND, OR, XOR, SHL, SHR.\n\nОперації з пам’яттю: MOV, LEA, PUSH, POP.\n\nКерування потоком виконання: JMP, CALL, RET, умовні переходи JE, JNE тощо.\n\nСистемні інструкції: HLT, INT, IRET, SYSCALL.\n\nВекторні операції (SSE, AVX) — дозволяють працювати з великими масивами даних одночасно (SIMD).\n\nОперації управління привілеями та режимами захисту — для роботи ОС (керування сегментацією, сторінками, режимами доступу).\n\nОсобливістю EM64T є наявність додаткових регістрів (R8–R15), 64-бітний стек і новий режим адресації.",
    "formulas": "Групи операцій EM64T:\n  - Арифметичні (ADD, SUB, MUL)\n  - Логічні (AND, OR, XOR)\n  - Переміщення (MOV, LEA)\n  - Управління потоком (JMP, CALL, RET)\n\nПояснення:\n*   Простою мовою: Це основні категорії команд, які розуміє сучасний 64-бітний процесор: для математики, для логіки, для копіювання даних та для переходів/виклику функцій.\n*   Професійно: Класифікація набору інструкцій архітектури x86-64 (EM64T) за функціональним призначенням."
  },
  "29": {
    "title": "Регістри, пам’ять, внутрішній стан процесора",
    "content": "Регістри: найшвидші елементи зберігання. Розділяються на:\n\nЗагального призначення (RAX, RBX…),\n\nІндексні (RSI, RDI),\n\nСтековий (RSP),\n\nЛічильник команд (RIP),\n\nФлаговий регістр (RFLAGS) — містить інформацію про стан процесора (нульовий результат, перенесення, переповнення тощо).\n\nПам’ять: ієрархічна — кеші (L1–L3), ОЗП, зовнішні накопичувачі. Кеш ближчий до процесора й значно швидший за RAM.\n\nВнутрішній стан процесора — це поточний вміст усіх регістрів, стан конвеєра, стан черг інструкцій, буферів передбачення переходів, тощо. Він визначає, на якому етапі виконання перебуває процесор і що має виконати далі."
  },
  "30": {
    "title": "Режими адресації в операціях переміщення даних",
    "content": "Режим адресації — це спосіб, за допомогою якого команда CPU визначає розташування операнда.\n\nОсновні:\n\nImmediate: MOV AX, 5 — значення вказано явно.\n\nDirect: MOV AX, [1234h] — операнд за конкретною адресою.\n\nIndirect: MOV AX, [BX] — адреса операнда міститься в регістрі.\n\nRegister: MOV AX, BX — операнди в регістрах.\n\nIndexed: MOV AX, [SI + offset] — для доступу до елементів масивів.\n\nBase + Index + Displacement: MOV AX, [BX + SI + offset] — складний режим, дозволяє адресувати поля структур, багатовимірні масиви тощо.\n\nЦі режими забезпечують гнучкість та ефективність при доступі до різних типів даних, включаючи елементи масивів, структур та стеку.",
    "formulas": "Режими адресації:\n  - Непосередній: MOV RAX, 10\n  - Регістровий: MOV RAX, RBX\n  - Пам’яті: MOV RAX, [RBX + 8]\n\nПояснення:\n*   Простою мовою: Це різні способи вказати команді, звідки брати дані: прямо з коду (число 10), з іншого регістра (RBX) або з комірки пам'яті за певною адресою.\n*   Професійно: Приклади основних режимів адресації в x86-64. Вони визначають, як процесор інтерпретує операнди інструкції для доступу до даних."
  },
  "31": {
    "title": "Структура адресного простору процесу прикладної програми",
    "content": "Адресний простір процесу — це область пам’яті, доступна процесу для виконання його коду і зберігання даних.\n\nТипова структура адресного простору:\n\nКодова секція (Text segment): Зберігає машинний код програми. Зазвичай доступна лише для читання.\n\nСекція даних (Data segment): Зберігає статично виділені змінні — ініціалізовані і неініціалізовані.\n\nСегмент стеку (Stack): Для зберігання локальних змінних, параметрів функцій і адрес повернення.\n\nКуча (Heap): Динамічно виділена пам’ять для об’єктів, які створюються під час виконання (через malloc, new).\n\nСегменти пам’яті, відведені під динамічне завантаження бібліотек і системні ресурси.\n\nУ 64-бітних системах адресний простір значно більший, що дозволяє одночасно розміщувати великі обсяги даних.",
    "formulas": "Адресний простір процесу:\n  Віртуальна пам’ять: 0x0000...FFFF\n  Кодування сегментів: текст, дані, стек\n\nПояснення:\n*   Простою мовою: Операційна система \"обманює\" кожну програму, створюючи ілюзію, що вона має всю пам'ять комп'ютера у своєму розпорядженні. Ця пам'ять логічно поділена на частини: код програми (текст), глобальні змінні (дані) та тимчасові дані (стек).\n*   Професійно: Опис віртуального адресного простору, який ОС надає кожному процесу. Він ізолює процеси один від одного і складається з сегментів для коду, ініціалізованих/неініціалізованих даних, та стеку."
  },
  "32": {
    "title": "Сегментна та сторінкова організація пам’яті",
    "content": "Сегментна організація: Пам’ять поділяється на логічні сегменти (код, дані, стек), кожен з яких має свій базовий адрес і довжину. Адреса у пам’яті формується як комбінація сегментного реєстру і зміщення (offset). Такий підхід дозволяє захищати пам’ять та організовувати ізоляцію процесів, але складний у керуванні і має обмеження за розміром сегментів.\n\nСторінкова організація: Пам’ять ділиться на фіксовані блоки — сторінки (зазвичай 4 КБ). Віртуальна адреса розбивається на номер сторінки та зміщення всередині сторінки. Система керування пам’яттю підтримує таблиці сторінок, що відображають віртуальні адреси у фізичні. Цей підхід дозволяє ефективно використовувати пам’ять, підтримувати віртуалізацію і захист.\n\nСучасні системи використовують комбінацію сегментної та сторінкової організації (наприклад, у x86), де сегменти використовуються для логічного поділу, а сторінки — для фізичного управління пам’яттю.",
    "formulas": "Сегментна та сторінкова організація:\n  Адреса = Сегмент × 16 + Зміщення\n  Пам’ять поділена на сторінки (4 КБ)\n\nПояснення:\n*   Простою мовою: Це механізм, за допомогою якого віртуальні адреси програми перетворюються на реальні адреси в оперативній пам'яті. Пам'ять ділиться на маленькі блоки-сторінки (зазвичай по 4 КБ) для зручного керування.\n*   Професійно: Описуються два механізми управління пам'яттю. Сегментація (застаріла в 64-бітних режимах) забезпечує логічний поділ, а сторінкова організація — фізичний поділ пам'яті на кадри для ефективного мапування віртуальних адрес на фізичні."
  },
  "33": {
    "title": "Виклик підпрограми в EM64T. Заповнення стеку та механізм повернення",
    "content": "Виклик підпрограми (функції) у архітектурі EM64T відбувається за допомогою інструкції CALL, яка виконує:\n\nЗапис адреси повернення: Поточне значення лічильника команд (RIP) зберігається у стек.\n\nПередача керування: RIP змінюється на адресу початку підпрограми.\n\nПеред викликом у стек або регістри записуються параметри, залежно від конвенції виклику (наприклад, у System V AMD64 параметри передаються через регістри RDI, RSI, RDX тощо).\n\nПід час виконання функції можуть створюватися локальні змінні, які розміщуються у стековому кадрі.\n\nДля повернення використовується інструкція RET, яка:\n\nЗавантажує адресу повернення зі стеку: Значення RIP відновлюється зі стеку.\n\nПереходить до точки виклику, продовжуючи виконання основної програми.",
    "formulas": "Виклик підпрограми (EM64T):\n  PUSH RBP\n  MOV RBP, RSP\n  ... (функція) ...\n  POP RBP\n  RET\n\nПояснення:\n*   Простою мовою: Це стандартний \"ритуал\" на початку та в кінці кожної функції. Він зберігає контекст викликаючої програми та готує спеціальну область в пам'яті (кадр стеку) для роботи поточної функції.\n*   Професійно: Це стандартний пролог та епілог функції в x86-64. Вони створюють та знищують кадр стеку, використовуючи регістри RBP (базовий вказівник кадру) та RSP (вказівник стеку) для керування доступом до параметрів та локальних змінних."
  },
  "34": {
    "title": "Кадр стеку та розміщення локальних змінних",
    "content": "Кадр стеку — це область пам’яті у стеку, що виділяється для однієї підпрограми під час її виконання.\n\nСтруктура кадру стеку:\n\nАдреса повернення: Зберігається для повернення у точку виклику.\n\nПопередній кадр стеку (Base Pointer): Вказує на базу попереднього кадру (фреймпоїнтер — RBP).\n\nЛокальні змінні: Займають область під кадром, виділену при виклику функції.\n\nЗбережені регістри: Регістр, які потрібно зберегти для відновлення після виконання підпрограми.\n\nРегістр RBP традиційно використовується як вказівник на базу поточного кадру стеку, а RSP вказує на вершину стеку.\n\nЦя організація дозволяє відновлювати стан програми після завершення функції та підтримувати рекурсію.",
    "formulas": "Кадр стеку:\n\n      |---------------------|  <-- Високі адреси\nRSP ->| Локальні змінні     |\n      |---------------------|\n      | Параметри функції   |\n      |---------------------|\nRBP ->| Адреса повернення   |\n      |---------------------|\n      | Попередній RBP      |\n      |---------------------|  <-- Низькі адреси\n\nде:\n  RBP — вказівник кадру\n  RSP — вказівник стеку\n\nПояснення:\n*   Простою мовою: Це тимчасова \"робоча зона\" для кожної функції, яка створюється в пам'яті при її виклику. Вона містить все, що потрібно функції для роботи, і знищується після її завершення.\n*   Професійно: Схематичне представлення кадру стеку (stack frame) в архітектурі x86-64. Це структура даних, що створюється на стеку для кожного виклику функції і містить її аргументи, адресу повернення та простір для локальних змінних."
  },
  "35": {
    "title": "Режими роботи процесора x86",
    "content": "Процесори архітектури x86 підтримують кілька режимів роботи, які визначають рівень доступу до ресурсів системи, функції апаратного забезпечення та можливості виконання коду:\n\nРеальний режим (Real Mode): Це початковий режим роботи процесора після включення живлення. Він підтримує 16-бітну адресацію з сегментно-офсетною схемою і обмежує доступ до 1 МБ пам’яті. Цей режим сумісний із старими програмами MS-DOS. Відсутня підтримка захисту пам’яті чи багатозадачності.\n\nЗахищений режим (Protected Mode): Введений з процесорами 80286 і вище, цей режим підтримує 32-бітну (а в пізніших — 64-бітну) адресацію, захист пам’яті, багатозадачність, кольця захисту (привілеїв) і віртуальну пам’ять. Тут процесор може працювати з кількома адресними просторами, ізоляцією програм, а також використовує таблиці сторінок і сегментів.\n\nВіртуальний 8086 режим (Virtual 8086 Mode): Підмножина захищеного режиму, яка дозволяє запускати віртуальні машини із старим 16-бітним кодом MS-DOS у вікні сучасної ОС, із захистом від прямого доступу до апаратури.\n\nРежим довгих адрес (Long Mode): Режим 64-бітної адресації, який доступний у архітектурах x86-64 (наприклад, EM64T від Intel). Включає підтримку 64-бітних регістрів, більших адресних просторів і розширених можливостей захисту.\n\nДля системного адміністратора розуміння цих режимів важливо для налаштування ОС, роботи з драйверами та діагностики апаратних проблем."
  },
  "36": {
    "title": "\"Кільця захисту\" та привілейований режим. Шлюз виклику.",
    "content": "У архітектурі x86 для підвищення безпеки та стабільності роботи системи використовується модель захисту за допомогою кілець захисту (protection rings) — рівнів привілеїв:\n\nВсього 4 кільця: 0, 1, 2, 3.\n\nКільце 0 (привілейований режим ядра) — найвищий рівень привілеїв, тут працює ядро ОС.\n\nКільця 1 і 2 — рідко використовуються, можуть застосовуватись для драйверів або системних служб.\n\nКільце 3 (звичайний користувацький режим) — найнижчий рівень, де працюють користувацькі програми.\n\nПривілейований режим — це режим роботи процесора з кільцем 0, де він має повний доступ до ресурсів апаратури і може виконувати критичні інструкції.\n\nШлюз виклику (Call Gate) — це механізм безпечного переходу між кільцями різного рівня привілеїв. Наприклад, коли програма в кільці 3 виконує системний виклик, щоб звернутися до ядра (кільце 0), вона проходить через шлюз виклику, який контролює доступ і забезпечує правильне налаштування контексту виконання.\n\nДля системного адміністратора це важливо для розуміння захисту ОС, механізмів безпеки і впровадження політик доступу."
  },
  "37": {
    "title": "Переривання",
    "content": "Переривання — це механізм апаратної або програмної події, що тимчасово призупиняє нормальне виконання коду процесора для обробки важливої задачі.\n\nАппаратні переривання: Генеруються зовнішніми пристроями (клавіатура, мережеві карти, таймери). Вони дозволяють ОС оперативно реагувати на події, наприклад, прийом даних.\n\nПрограмні переривання: Виникають через виконання спеціальних інструкцій (наприклад, виклики системних викликів через інструкцію int в x86).\n\nПри перериванні процесор зберігає свій стан, переходить у привілейований режим і виконує код обробника переривання (Interrupt Service Routine, ISR).\n\nДля системного адміністратора розуміння переривань критичне для налагодження драйверів і оптимізації роботи системи."
  },
  "38": {
    "title": "Підходи до реалізації багатозадачності на сучасних процесорах",
    "content": "Багатозадачність — це здатність ОС одночасно виконувати кілька процесів або потоків.\n\nПріоритетне планування: ОС призначає пріоритети процесам, і процесор виділяється в першу чергу процесам з вищим пріоритетом.\n\nВитісняюча багатозадачність: ОС примусово припиняє виконання поточного процесу через таймерні переривання і переключає процесор на інший процес.\n\nКооперативна багатозадачність: Процеси самостійно здають управління ОС.\n\nМультипроцесорність (SMP): Декілька процесорних ядер виконують задачі паралельно.\n\nВіртуалізація: Запуск кількох віртуальних ОС одночасно.\n\nДля системного адміністратора це важливо при налаштуванні серверів, оптимізації ресурсів, і розумінні роботи ОС."
  },
  "39": {
    "title": "Трансляція та інтерпретація програмного коду",
    "content": "Трансляція (компіляція): Перетворення вихідного коду високорівневої мови у машинний код (або проміжний байт-код) до запуску програми. Наприклад, компілятор gcc створює бінарний файл. Переваги — висока швидкість виконання, мінімальні накладні витрати під час роботи.\n\nІнтерпретація: Програма виконується по рядках, код перекладається та виконується одночасно (інтерпретатор). Приклад — скриптові мови Python, JavaScript. Переваги — швидка розробка, зручність налагодження, кросплатформеність.\n\nДля системного адміністратора знання цих підходів допомагає у виборі середовища для запуску програм, розумінні продуктивності та безпеки."
  },
  "40": {
    "title": "Статичне та динамічне зв’язування програмних модулів",
    "content": "Статичне зв’язування: Під час компіляції всі необхідні бібліотеки включаються безпосередньо у виконуваний файл. Плюси — відсутність залежностей під час запуску, мінімальна затримка завантаження. Мінуси — більший розмір файлу, складність оновлення.\n\nДинамічне зв’язування: Виконувані програми використовують зовнішні бібліотеки (shared libraries, DLLs, .so), які завантажуються під час запуску або роботи програми. Плюси — менший розмір, гнучкість оновлення бібліотек без перекомпіляції програми. Мінуси — можливі проблеми з сумісністю (так званий \"DLL hell\").\n\nДля системного адміністратора це важливо при розгортанні ПЗ, оновленні систем та підтримці сумісності."
  },
  "41": {
    "title": "Структура форматів виконуваних файлів. Сегменти та секції",
    "content": "Виконувані файли — це файли, які містять машинний код і метаінформацію, необхідну для запуску програми. Найпоширеніші формати — ELF (Unix/Linux), PE (Windows), Mach-O (macOS). Кожен формат має внутрішню структуру, яка забезпечує правильне завантаження програми в пам’ять і її виконання.\n\nОсновні компоненти виконуваного файлу:\n\nЗаголовок (Header):\nМістить службову інформацію, яка визначає:\n\nтип виконуваного файлу (наприклад, ELF64 або PE32),\n\nархітектуру процесора (x86, ARM),\n\nточку входу (entry point) — адресу, з якої починається виконання програми,\n\nрозміри сегментів і вирівнювання,\n\nінформацію про таблиці програм і секцій.\n\nСегменти:\nЦе великі блоки даних, які завантажуються у віртуальний адресний простір програми. Вони визначають, як і де розміщується в пам’яті різні частини програми.\n\nНаприклад, loadable segments у ELF: код, дані, стек.\n\nКожен сегмент має атрибути доступу (тільки читання, читання-запис, виконання).\n\nСекції (Sections):\nЛогічні підрозділи всередині сегментів. У секціях зберігаються окремі частини коду або даних.\n\n.text — машинний код програми (тільки для читання, з виконанням),\n\n.data — ініціалізовані глобальні змінні (читання-запис),\n\n.bss — неініціалізовані змінні (фізично не займає місце у файлі, але виділяється при запуску),\n\n.rodata — константи (тільки для читання),\n\n.symtab, .strtab, .debug — службові секції для налагодження, символів тощо.\n\nДодаткові таблиці:\n\nТаблиця секцій (Section Table): описує кожну секцію, її тип, розмір, віртуальну адресу тощо.\n\nТаблиця програм (Program Header Table): використовується завантажувачем для ініціалізації адресного простору.\n\nЗнання структури виконуваних файлів дозволяє:\n\nАналізувати запуск програм, шукати помилки при запуску (наприклад, відсутність точок входу, неправильні права доступу).\n\nВиявляти шкідливий код або зміни у бінарних файлах.\n\nНалагоджувати проблеми із сумісністю на рівні ОС.\n\nКонтролювати безпеку (наприклад, через політики ASLR, DEP, цифрові підписи PE-файлів)."
  },
  "42": {
    "title": "Збірка програмного проекту. Інструментарій збірки",
    "content": "Процес збірки — це створення виконуваного файлу (або бібліотеки) з вихідного коду. Це важливий етап у життєвому циклі ПЗ, який включає кілька стадій.\n\nОсновні етапи збірки:\n\nПопередня обробка (Preprocessing):\n\nРозширення макросів, підключення заголовочних файлів (#include), обробка директив (#define, #ifdef тощо).\n\nКомпіляція (Compilation):\n\nПеретворення коду з мови програмування (наприклад, C/C++) у об'єктний код (.o, .obj), який містить машинні інструкції.\n\nАссемблювання (Assembly):\n\nУ деяких випадках, окремий етап, що перетворює проміжний асемблерний код у машинний.\n\nЛінкування (Linking):\n\nОб’єднання кількох об'єктних файлів та бібліотек у виконуваний файл.\n\nВирішуються зовнішні символи (виклики функцій, змінні).\n\nПідключаються стандартні або сторонні бібліотеки (наприклад, libc, libm).\n\nПостобробка:\n\nОптимізація, зменшення розміру, підпис файлу, вставка метаданих.\n\nІнструменти, що використовуються при збірці:\n\nКомпілятори:\n\ngcc, clang, msvc — основні для C/C++.\n\nВизначають параметри оптимізації (-O2, -g, -Wall тощо).\n\nЛінкери:\n\nld, gold, lld — поєднують об'єктні файли у виконуваний файл.\n\nЗасоби автоматизації збірки:\n\nMake — класична утиліта для опису залежностей і автоматичної збірки.\n\nCMake — сучасна система, що генерує make-файли або проєкти IDE.\n\nninja, meson — швидкі і мінімалістичні альтернативи.\n\nДодаткові утиліти:\n\ngdb, valgrind — налагодження і виявлення помилок у пам’яті.\n\ngcov, gprof — тестування і профілювання.\n\nstrip — видалення відлагоджувальної інформації.\n\nДля системного адміністратора це важливо тому, що:\n\nДає змогу автоматизувати складання програм на серверах (CI/CD).\n\nДозволяє розуміти, як зібрати сторонній або open-source проєкт зі сирців.\n\nДозволяє змінювати конфігурацію збірки (режим debug/release, шляхи до бібліотек).\n\nПолегшує налагодження проблем при запуску або при збиранні залежностей."
  },
  "43": {
    "title": "Автоматизація збірки. Утиліта Make",
    "content": "Make — це класична утиліта для автоматизації процесу збірки програмного забезпечення. Вона базується на текстовому файлі Makefile, у якому описуються:\n\nЗалежності між вихідними файлами, об'єктними файлами та виконуваними файлами.\n\nПравила (rules), які містять команди для перетворення файлів (наприклад, компіляція, лінкування).\n\nОсновні переваги Make:\n\nІнкрементальна збірка — Make перевіряє дати модифікації файлів і виконує тільки ті команди, які потрібні для оновлення застарілих частин проєкту. Це значно пришвидшує збірку великих проектів.\n\nПідтримка складних залежностей, що дозволяє чітко описувати, які файли від яких залежать.\n\nЛегкість у використанні на серверних середовищах для автоматизації збірки, тестування і навіть розгортання ПЗ.\n\nMakefile може містити складну логіку із умовами, змінними та вкладеними викликами.\n\nДля системного адміністратора важливо:\n\nВміти писати та підтримувати Makefile для автоматизації збірки і оновлення програм.\n\nВикористовувати Make у скриптах CI/CD для швидкої і надійної побудови програмного продукту.\n\nЛегко інтегрувати збірку із іншими утилітами та інструментами (наприклад, тестуванням)."
  },
  "44": {
    "title": "Механізм системних викликів",
    "content": "Системний виклик — це основний спосіб, за допомогою якого програма взаємодіє із ядром операційної системи для виконання операцій, які потребують підвищених прав.\n\nЯк це працює:\n\nПрограма викликає системний виклик через спеціальну інструкцію (на архітектурі x86 це може бути int 0x80 або syscall).\n\nЦя інструкція переводить процесор у привілейований режим (kernel mode), де ядро має повний доступ до ресурсів.\n\nЯдро виконує необхідну операцію (наприклад, читання файлу, відкриття сокета, виділення пам’яті).\n\nПісля завершення операції ядро повертає результат у користувацький режим.\n\nВажливі аспекти:\n\nСистемні виклики — це основа безпеки ОС, бо саме ядро контролює доступ до апаратних і системних ресурсів.\n\nРозуміння системних викликів допомагає діагностувати помилки, проблеми з продуктивністю, а також розуміти поведінку програм."
  },
  "45": {
    "title": "Створення нових процесів за допомогою викликів fork() та execve()",
    "content": "Для запуску нових програм і процесів у Unix-подібних системах використовують два основні системні виклики:\n\nfork()\nСтворює копію поточного процесу — дочірній процес, який є ідентичним за станом, але має свій унікальний PID (Process ID). Після виклику існує два процеси, що виконуються паралельно.\n\nexecve()\nЗамінює вміст поточного процесу іншим виконуваним файлом. Після виклику execve поточний код, пам’ять та стек замінюються програмою, яка запускається.\n\nЗастосування комбінації fork + exec:\n\nСпочатку створюється новий процес копіюванням (fork).\n\nПотім дочірній процес замінюється новою програмою (execve).\n\nТакий механізм є основою запуску будь-яких нових процесів у системі (в тому числі сервісів).\n\nДля системного адміністратора:\n\nРозуміння fork/exec дозволяє краще управляти процесами, контролювати запуск сервісів і написання скриптів.\n\nДопомагає діагностувати проблеми із зависанням процесів, багатьма копіями, помилками запуску програм."
  },
  "46": {
    "title": "Файлові дескриптори та основні файлові операції",
    "content": "Файловий дескриптор (FD) — це ціле число, яке ідентифікує відкритий файл або інший ресурс операційної системи, наприклад, трубку (pipe), сокет або пристрій.\n\nОсновні системні виклики:\n\nopen() — відкриває файл і повертає файловий дескриптор.\n\nread() — читає дані з файлу за дескриптором.\n\nwrite() — записує дані у файл.\n\nclose() — закриває дескриптор, звільняючи ресурс.\n\nlseek() — змінює поточну позицію у файлі (корисно для випадкового доступу).\n\nЗначення для системного адміністратора:\n\nМоніторинг відкритих дескрипторів для уникнення їх витоків (наприклад, через lsof).\n\nВміння налагоджувати проблеми з файловими ресурсами (наприклад, коли файли не закриваються).\n\nРобота з логами та іншими файловими потоками."
  },
  "47": {
    "title": "Інтерфейс сокетів (Berkeley Sockets)",
    "content": "Berkeley Sockets — це стандартний API для мережевого програмування у Unix-подібних системах.\n\nПідтримує основні мережеві протоколи:\n\nTCP (надійний потік байтів)\n\nUDP (пакетний, без з’єднання)\n\nОсновні функції:\n\nsocket() — створення сокету.\n\nbind() — прив’язка сокету до IP-адреси і порту.\n\nlisten() — перехід у режим очікування вхідних з’єднань.\n\naccept() — прийом нового з’єднання.\n\nconnect() — встановлення з’єднання до віддаленого хоста.\n\nsend(), recv() — відправка та прийом даних.\n\nЗначення для системного адміністратора:\n\nДіагностика мережевих проблем (перевірка роботи сервісів на сокетах).\n\nНалаштування міжмережевого екрану (Firewall) і безпеки.\n\nКонтроль роботи серверних застосунків."
  },
  "48": {
    "title": "Відображення файлів в пам'ять",
    "content": "Функція mmap() — це механізм, який дозволяє відобразити вміст файлу або пристрою безпосередньо у віртуальний адресний простір процесу.\n\nПереваги mmap():\n\nШвидкий доступ до даних без необхідності багаторазових системних викликів читання/запису.\n\nМожливість спільного доступу до пам’яті між процесами.\n\nСпрощення роботи з великими файлами, базами даних, кешуванням.\n\nВажливість для системного адміністратора:\n\nОптимізація продуктивності додатків через контроль використання mmap.\n\nУправління пам’яттю і ресурсами.\n\nВиявлення проблем із доступом до відображених файлів."
  }
}